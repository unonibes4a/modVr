<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Video Player</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
        #youtubeContainer {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="youtubeContainer"></div>
    <div id="controls">
        <input type="file" id="videoInput" accept="video/*">
        <button id="playPauseBtn">Play/Pause</button>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1">
        <button id="vrButton">Enter VR</button>
        <input type="text" id="youtubeUrl" placeholder="Enter YouTube Video ID">
        <button id="loadYoutubeBtn">Load YouTube Video</button>
    </div>

    <script>  

const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera, videoTexture, videoMaterial, videoPlane;
        let isPlaying = false;
        let youtubePlayer;
let pathvideos='https://unonibes4a.github.io/temasbrochas/';
        const createScene = async function () {
            scene = new BABYLON.Scene(engine);
     
            camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
            camera.setPosition(new BABYLON.Vector3(0, 0, -10));
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            videoTexture = new BABYLON.VideoTexture("videoTexture",pathvideos+ "video1.mp4", scene, true, false, BABYLON.VideoTexture.TRILINEAR_SAMPLINGMODE, {
                autoPlay: false,
                loop: false,
                autoUpdateTexture: true
            });

            videoTexture.video.muted = false;

            videoMaterial = new BABYLON.StandardMaterial("videoMaterial", scene);
            videoMaterial.diffuseTexture = videoTexture;
            videoMaterial.emissiveColor = new BABYLON.Color3.White();

            const aspectRatio = engine.getAspectRatio(camera);
            const planeWidth = 4;
            const planeHeight = planeWidth / aspectRatio;

            videoPlane = BABYLON.MeshBuilder.CreatePlane("videoPlane", {width: planeWidth, height: planeHeight}, scene);
            videoPlane.material = videoMaterial;

            const env = scene.createDefaultEnvironment({
    skyboxColor: new BABYLON.Color3(0.00, 0.0, 0.0)   
});
            if (window.location.protocol === 'https:') {
                try {
                    const xr = await scene.createDefaultXRExperienceAsync({
                        floorMeshes: [env.ground]
                    });
                    console.log("WebXR initialized successfully");
                } catch (error) {
                    console.error("Failed to initialize WebXR:", error);
                }
            } else {
                console.warn("WebXR requires HTTPS. VR features will be disabled.");
            }

          
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            
            const button1 = BABYLON.GUI.Button.CreateSimpleButton("but1", "Play/Pause");
            button1.width = 0.2;
            button1.height = "40px";
            button1.color = "white";
            button1.cornerRadius = 20;
            button1.background = "green";
            button1.onPointerUpObservable.add(function() {
                togglePlayPause();
            });
            advancedTexture.addControl(button1);
            var environment = scene.createDefaultEnvironment({ enableGroundShadow: true, groundYBias: 2.8 });
            environment.setMainColor(BABYLON.Color3.FromHexString("#000000"))
           var boolpressvr=true;
           videoPlane.position = new BABYLON.Vector3(0, 0, -8);
            var vrHelper = scene.createDefaultVRExperience({createDeviceOrientationCamera:false, useXR: true});
            vrHelper.enableTeleportation({floorMeshes: [environment.ground]});
            vrHelper.onAfterEnteringVRObservable.add(()=>{
                if(scene.activeCamera === vrHelper.vrDeviceOrientationCamera){
               
                   boolpressvr=!boolpressvr;
                }
            });
           
            scene.debugLayer.show({
  embedMode: true
});

 
            return scene;
        };

        createScene().then(scene => {
            engine.runRenderLoop(function () {
                scene.render();
            });
        }).catch(error => {
            console.error("Error creating scene:", error);
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });

        function togglePlayPause() {
            if (isPlaying) {
                videoTexture.video.pause();
            } else {
                videoTexture.video.play();
            }
            isPlaying = !isPlaying;
        }

        const playPauseBtn = document.getElementById("playPauseBtn");
        playPauseBtn.addEventListener("click", togglePlayPause);

        const volumeSlider = document.getElementById("volumeSlider");
        volumeSlider.addEventListener("input", function() {
            videoTexture.video.volume = volumeSlider.value;
        });

        const videoInput = document.getElementById("videoInput");
        videoInput.addEventListener("change", function(event) {
            const file = event.target.files[0];
            const videoUrl = URL.createObjectURL(file);
            videoTexture.updateURL(videoUrl);
            videoTexture.video.muted = false;
        });

        const vrButton = document.getElementById("vrButton");
        vrButton.addEventListener("click", function() {
            if (window.location.protocol === 'https:') {
                scene.createDefaultXRExperienceAsync({
                    floorMeshes: [scene.getMeshByName("ground1")]
                }).then((xrExperience) => {
                    xrExperience.enterExperienceAsync();
                }).catch(error => {
                    console.error("Error entering VR:", error);
                });
            } else {
                alert("VR requires HTTPS. Please use a secure connection.");
            }
        });

      
        function onYouTubeIframeAPIReady() {
            youtubePlayer = new YT.Player('youtubeContainer', {
                height: '100%',
                width: '100%',
                videoId: 'M7lc1UVf-VE',
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        function onPlayerReady(event) {
            console.log("YouTube player is ready");
        }

        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.PLAYING) {
                isPlaying = true;
            } else if (event.data == YT.PlayerState.PAUSED) {
                isPlaying = false;
            }
        }

        const youtubeUrlInput = document.getElementById("youtubeUrl");
        const loadYoutubeBtn = document.getElementById("loadYoutubeBtn");
        loadYoutubeBtn.addEventListener("click", function() {
            const youtubeId = youtubeUrlInput.value;
            if (youtubePlayer && youtubeId) {
                youtubePlayer.loadVideoById(youtubeId);
                document.getElementById('youtubeContainer').style.display = 'block';
                canvas.style.display = 'none';
            }
        });

        function createDefautlEnv(scene,distancia=1000,path="https://unonibes4a.github.io/PinturaGio3D/env.env"){
  scene.createDefaultSkybox(new BABYLON.CubeTexture(path, scene), true, distancia); 
}
    </script>
</body>
</html>